/* Generated By:JavaCC: Do not edit this line. Parser.java */
package lexicalAnalysis;

import syntaxtree.*;
import java.util.ArrayList;

public class Parser implements ParserConstants {

/*A função Program() analisa a execusão das variaveis do tipo MainClass() e ClassDecl() nela */
  static final public Program Program() throws ParseException {
  MainClass m; ClassDecl cd; ClassDeclList cdl = new ClassDeclList();
    m = MainClass();
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CLASS:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      cd = ClassDecl();
                                          cdl.addElement(cd);
    }
                                                                     {if (true) return new Program(m,cdl);}
    throw new Error("Missing return statement in function");
  }

/* Nesssa função é analisado a declaração de uma variavel de um certo tipo */
  static final public VarDecl VarDecl() throws ParseException {
  Type t; Token i;
    t = Type();
    i = jj_consume_token(ID);
    jj_consume_token(SEMICOLON);
                                       {if (true) return new VarDecl(t,new Identifier(i.image));}
    throw new Error("Missing return statement in function");
  }

/*Nessa função é analisado a construção de um método  */
  static final public MethodDecl MethodDecl() throws ParseException {
  Type t; Token i; Formal f; VarDecl vd; Statement s; Exp e;
  FormalList fl = new FormalList(); VarDeclList vl = new VarDeclList(); StatementList sl = new StatementList();
    jj_consume_token(PUBLIC);
    t = Type();
    i = jj_consume_token(ID);
    jj_consume_token(LPAREN);
    fl = FormalList();
    jj_consume_token(RPAREN);
    jj_consume_token(LBRACE);
    label_2:
    while (true) {
      if (jj_2_1(2)) {
        ;
      } else {
        break label_2;
      }
      vd = VarDecl();
                                  vl.addElement(vd);
    }
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IF:
      case WHILE:
      case SYSTEMOUTPRINTLN:
      case LBRACE:
      case ID:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_3;
      }
      s = Statement();
                                                                             sl.addElement(s);
    }
    jj_consume_token(RETURN);
    e = Exp();
    jj_consume_token(SEMICOLON);
    jj_consume_token(RBRACE);
    {if (true) return new MethodDecl(t,new Identifier(i.image),fl,vl,sl,e);}
    throw new Error("Missing return statement in function");
  }

/*Nessa função é analizado a classe main: os tokens ai1 ai2  é reconhecido
por conjuntos de caracteres da calsse main, o Statement as também é reconhedo
 pelo Statement difinido na propria função */
  static final public MainClass MainClass() throws ParseException {
  Token ai1,ai2; Statement as;
    jj_consume_token(CLASS);
    ai1 = jj_consume_token(ID);
    jj_consume_token(LBRACE);
    jj_consume_token(PUBLIC);
    jj_consume_token(STATIC);
    jj_consume_token(VOID);
    jj_consume_token(MAIN);
    jj_consume_token(LPAREN);
    jj_consume_token(STRING);
    jj_consume_token(LBRACKET);
    jj_consume_token(RBRACKET);
    ai2 = jj_consume_token(ID);
    jj_consume_token(RPAREN);
    jj_consume_token(LBRACE);
    as = Statement();
    jj_consume_token(RBRACE);
    jj_consume_token(RBRACE);
    {if (true) return new MainClass(new Identifier(ai1.image),new Identifier(ai2.image),as);}
    throw new Error("Missing return statement in function");
  }

/* Nesssa função é analisado a declaração de uma variavel */
  static final public ClassDecl ClassDecl() throws ParseException {
  Token id; ClassDecl cd;
    jj_consume_token(CLASS);
    id = jj_consume_token(ID);
    cd = ClassDeclII(new Identifier(id.image));
    {if (true) return cd;}
    throw new Error("Missing return statement in function");
  }

/*Nessa função é analisado a construção de uma classe */
  static final public ClassDecl ClassDeclII(Identifier i) throws ParseException {
  Token id; MethodDecl md; VarDecl vd = null; VarDeclList vdl = new VarDeclList(); MethodDeclList mdl = new MethodDeclList();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      jj_consume_token(LBRACE);
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INT:
        case BOOLEAN:
        case ID:
          ;
          break;
        default:
          jj_la1[2] = jj_gen;
          break label_4;
        }
        vd = VarDecl();
                    vdl.addElement(vd);
      }
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PUBLIC:
          ;
          break;
        default:
          jj_la1[3] = jj_gen;
          break label_5;
        }
        md = MethodDecl();
                                                                  mdl.addElement(md);
      }
      jj_consume_token(RBRACE);
    {if (true) return new ClassDeclSimple(i, vdl, mdl);}
      break;
    default:
      jj_la1[6] = jj_gen;
      if (jj_2_2(3)) {
        jj_consume_token(EXTENDS);
        id = jj_consume_token(ID);
        jj_consume_token(LBRACE);
        label_6:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case INT:
          case BOOLEAN:
          case ID:
            ;
            break;
          default:
            jj_la1[4] = jj_gen;
            break label_6;
          }
          vd = VarDecl();
                    vdl.addElement(vd);
        }
        label_7:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case PUBLIC:
            ;
            break;
          default:
            jj_la1[5] = jj_gen;
            break label_7;
          }
          md = MethodDecl();
                                                                  mdl.addElement(md);
        }
        jj_consume_token(RBRACE);
    {if (true) return new ClassDeclExtends(i,new Identifier(id.image),vdl,mdl);}
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

/*Nessa função é analisado o tipo de uma variavel, se é inteiro ou boleano  */
  static final public Type Type() throws ParseException {
  Token id; Type type;
    if (jj_2_3(2)) {
      jj_consume_token(INT);
      type = TypeII();
                            {if (true) return type;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
        jj_consume_token(BOOLEAN);
                {if (true) return new BooleanType();}
        break;
      case ID:
        id = jj_consume_token(ID);
  {if (true) return new IdentifierType(id.image);}
        break;
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

/*Nessa função é analisado se o tipo de uma variavel, é inteiro ou uma lista de inteiros  */
  static final public Type TypeII() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACKET:
      jj_consume_token(LBRACKET);
      jj_consume_token(RBRACKET);
                                {if (true) return new IntArrayType();}
      break;
    default:
      jj_la1[8] = jj_gen;
      ;
    }
                                                                  {if (true) return new IntegerType();}
    throw new Error("Missing return statement in function");
  }

/* A função FormalRest() do tipo Formal é sempre o próximo parametro de uma funçao*/
  static final public Formal FormalRest() throws ParseException {
  Type t; Token i;
    jj_consume_token(COMMA);
    t = Type();
    i = jj_consume_token(ID);
                                    {if (true) return new Formal(t,new Identifier(i.image));}
    throw new Error("Missing return statement in function");
  }

/*Na função Statemant é analizado as condição do tipo "if", "while",
onde cada um é considerado um statement. Também as funções Block que
garega uma lista de statement, função "print" que mostra na tela uma expressão,
 uma identificador de Variavel "a" do tipo IdentifierAssign da função StatementII*/
  static final public Statement Statement() throws ParseException {
  Statement s1; Statement s2; StatementList sl = new StatementList(); Exp e; Exp e2; Token i; Statement s; IdentifierAssign a;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      jj_consume_token(LBRACE);
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IF:
        case WHILE:
        case SYSTEMOUTPRINTLN:
        case LBRACE:
        case ID:
          ;
          break;
        default:
          jj_la1[9] = jj_gen;
          break label_8;
        }
        s1 = Statement();
                                 sl.addElement(s1);
      }
      jj_consume_token(RBRACE);
    {if (true) return new Block(sl);}
      break;
    case IF:
      jj_consume_token(IF);
      jj_consume_token(LPAREN);
      e = Exp();
      jj_consume_token(RPAREN);
      s1 = Statement();

      jj_consume_token(ELSE);
      s2 = Statement();
                                                                                        {if (true) return new If(e,s1,s2);}
      break;
    case WHILE:
      jj_consume_token(WHILE);
      jj_consume_token(LPAREN);
      e = Exp();
      jj_consume_token(RPAREN);
      s1 = Statement();
                                                               {if (true) return new While(e,s1);}
      break;
    case SYSTEMOUTPRINTLN:
      jj_consume_token(SYSTEMOUTPRINTLN);
      jj_consume_token(LPAREN);
      e = Exp();
      jj_consume_token(RPAREN);
      jj_consume_token(SEMICOLON);
                                                                       {if (true) return new Print(e);}
      break;
    default:
      jj_la1[10] = jj_gen;
      if (jj_2_4(2)) {
        i = jj_consume_token(ID);
        a = StatementII(new Identifier(i.image));
                                                        a.id = new Identifier(i.image); {if (true) return a;}
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

/*A função StatementII é um IdentifierAssign que analisa a atribuição
 de um expressão ou lista de expressão a uma variavel*/
  static final public IdentifierAssign StatementII(Identifier i) throws ParseException {
  Exp exp,exp2;
    if (jj_2_5(2)) {
      jj_consume_token(ASSIGN);
      exp = Exp();
      jj_consume_token(SEMICOLON);
                                         {if (true) return new Assign(i, exp);}
    } else if (jj_2_6(2)) {
      jj_consume_token(LBRACKET);
      exp = Exp();
      jj_consume_token(RBRACKET);
      jj_consume_token(ASSIGN);
      exp2 = Exp();
      jj_consume_token(SEMICOLON);
                                                                                {if (true) return new ArrayAssign(i, exp, exp2 );}
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/* A função FormalList() analisa as vaviaveis de certo tipo que faz parte
do parametro de uma função*/
  static final public FormalList FormalList() throws ParseException {
  Type t; Formal f; Token i;
  FormalList fl = new FormalList();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT:
    case BOOLEAN:
    case ID:
      t = Type();
      i = jj_consume_token(ID);
                         fl.addElement(new Formal(t,new Identifier(i.image)));
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[11] = jj_gen;
          break label_9;
        }
        f = FormalRest();
                                                                                                     fl.addElement(f);
      }
      break;
    default:
      jj_la1[12] = jj_gen;
      ;
    }
  {if (true) return fl;}
    throw new Error("Missing return statement in function");
  }

/*Nessa função é analisado operações entre tokens com operadores
"PLUS, MINUS, MULTIPLY, LT" e funcionamento token "DOT" e tratamento
 da recursividade a esquerda*/
  static final public Exp ExpL(Exp expL) throws ParseException {
  Exp exp1, exp2, exp3; ExpList el = new ExpList(); Token t;
    if (jj_2_9(2)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        jj_consume_token(PLUS);
        exp1 = Exp();
        exp2 = ExpL(new Plus(expL,exp1));
    if (exp2 != null) { {if (true) return exp2;} }
    else { {if (true) return new Plus(expL,exp1);} }
        break;
      case MINUS:
        jj_consume_token(MINUS);
        exp1 = Exp();
        exp2 = ExpL(new Minus(expL, exp1));
    if (exp2 != null) { {if (true) return exp2;} }
    else { {if (true) return new Minus(expL,exp1);} }
        break;
      case MULTIPLY:
        jj_consume_token(MULTIPLY);
        exp1 = Exp();
        exp2 = ExpL(new Times(expL, exp1));
    if (exp2 != null) { {if (true) return exp2;} }
    else { {if (true) return new Times(expL,exp1);} }
        break;
      case LT:
        jj_consume_token(LT);
        exp1 = Exp();
        exp2 = ExpL(new LessThan(expL, exp1));
    if (exp2 != null) { {if (true) return exp2;} }
    else { {if (true) return new LessThan(expL,exp1);} }
        break;
      case AND:
        jj_consume_token(AND);
        exp1 = Exp();
        exp2 = ExpL(new And(expL, exp1));
    if (exp2 != null) { {if (true) return exp2;} }
    else { {if (true) return new And(expL,exp1);} }
        break;
      case LBRACKET:
        jj_consume_token(LBRACKET);
        exp1 = Exp();
        jj_consume_token(RBRACKET);
        exp2 = ExpL(new ArrayLookup(expL,exp1));
    if (exp2 != null) { {if (true) return exp2;} }
    else { {if (true) return new ArrayLookup(expL,exp1);} }
        break;
      default:
        jj_la1[15] = jj_gen;
        if (jj_2_7(2)) {
          jj_consume_token(DOT);
          jj_consume_token(LENGTH);
          exp2 = ExpL(new ArrayLength(expL));
    if (exp2 != null) { {if (true) return exp2;} }
    else { {if (true) return new ArrayLength(expL);} }
        } else if (jj_2_8(2)) {
          jj_consume_token(DOT);
          t = jj_consume_token(ID);
          jj_consume_token(LPAREN);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case TRUE:
          case FALSE:
          case NEW:
          case THIS:
          case LPAREN:
          case NOT:
          case INTEGER_LITERAL:
          case ID:
            exp1 = Exp();
                                                              el.addElement(exp1);
            label_10:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case COMMA:
                ;
                break;
              default:
                jj_la1[13] = jj_gen;
                break label_10;
              }
              jj_consume_token(COMMA);
              exp2 = Exp();
                           el.addElement(exp2);
            }
            break;
          default:
            jj_la1[14] = jj_gen;
            ;
          }
          jj_consume_token(RPAREN);
          exp3 = ExpL(new Call(expL, new Identifier(t.image), el));
    if (exp3 != null) { {if (true) return exp3;} }
    else { {if (true) return new Call(expL, new Identifier(t.image), el);} }
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } else {
      ;
    }
  {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

/*Nessa função é analisado o funcionamento de tokens do tipo "INTEGER_LITERAL,
beleano TRUE e FALSE" e de alguns tokens como "ID, NOT, THIS, NEW" com expressões
e tratamento da recursividade a esquerda*/
  static final public Exp Exp() throws ParseException {
  Token t; Exp exp, exp2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      t = jj_consume_token(INTEGER_LITERAL);
      exp = ExpL(new IntegerLiteral(Integer.parseInt(t.image)));
    if(exp != null)
    { {if (true) return exp;} }
    else
    { {if (true) return new IntegerLiteral(Integer.parseInt(t.image));} }
      break;
    case TRUE:
      jj_consume_token(TRUE);
      exp = ExpL(new True());
    if(exp != null) { {if (true) return exp;} }
    else { {if (true) return new True();} }
      break;
    case FALSE:
      jj_consume_token(FALSE);
      exp = ExpL(new False());
    if(exp != null) { {if (true) return exp;} }
    else { {if (true) return new False();} }
      break;
    case ID:
      t = jj_consume_token(ID);
      exp = ExpL(new IdentifierExp(t.image));
    if(exp != null) { {if (true) return exp;} }
    else { {if (true) return new IdentifierExp(t.image);} }
      break;
    case THIS:
      jj_consume_token(THIS);
      exp = ExpL(new This());
    if(exp != null) { {if (true) return exp;} }
    else { {if (true) return new This();} }
      break;
    default:
      jj_la1[16] = jj_gen;
      if (jj_2_10(2)) {
        jj_consume_token(NEW);
        jj_consume_token(INT);
        jj_consume_token(LBRACKET);
        exp = Exp();
        jj_consume_token(RBRACKET);
        exp2 = ExpL(new NewArray(exp));
    if(exp2 != null) { {if (true) return exp2;} }
    else { {if (true) return new NewArray(exp);} }
      } else if (jj_2_11(2)) {
        jj_consume_token(NEW);
        t = jj_consume_token(ID);
        jj_consume_token(LPAREN);
        jj_consume_token(RPAREN);
        exp = ExpL(new NewObject(new Identifier(t.image)));
    if (exp != null) { {if (true) return exp;} }
    else { {if (true) return new NewObject(new Identifier(t.image));} }
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NOT:
          jj_consume_token(NOT);
          exp = Exp();
          exp2 = ExpL(new Not(exp));
    if (exp2 != null) { {if (true) return exp2;} }
    else { {if (true) return new Not(exp);} }
          break;
        case LPAREN:
          jj_consume_token(LPAREN);
          exp = Exp();
          jj_consume_token(RPAREN);
          exp2 = ExpL(exp);
        if (exp2 != null) { {if (true) return exp2;} }
      else { {if (true) return exp;} }
          break;
        default:
          jj_la1[17] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    throw new Error("Missing return statement in function");
  }

  static private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  static private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  static private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  static private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  static private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  static private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  static private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  static private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  static private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  static private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  static private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  static private boolean jj_3_7() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(LENGTH)) return true;
    return false;
  }

  static private boolean jj_3R_27() {
    if (jj_scan_token(THIS)) return true;
    return false;
  }

  static private boolean jj_3R_22() {
    if (jj_scan_token(LBRACKET)) return true;
    return false;
  }

  static private boolean jj_3R_12() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_22()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_20() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_14()) return true;
    return false;
  }

  static private boolean jj_3R_26() {
    if (jj_scan_token(ID)) return true;
    return false;
  }

  static private boolean jj_3_6() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_14()) return true;
    return false;
  }

  static private boolean jj_3R_19() {
    if (jj_scan_token(AND)) return true;
    if (jj_3R_14()) return true;
    return false;
  }

  static private boolean jj_3R_31() {
    if (jj_scan_token(ID)) return true;
    return false;
  }

  static private boolean jj_3R_25() {
    if (jj_scan_token(FALSE)) return true;
    return false;
  }

  static private boolean jj_3R_30() {
    if (jj_scan_token(BOOLEAN)) return true;
    return false;
  }

  static private boolean jj_3_5() {
    if (jj_scan_token(ASSIGN)) return true;
    if (jj_3R_14()) return true;
    return false;
  }

  static private boolean jj_3R_13() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_5()) {
    jj_scanpos = xsp;
    if (jj_3_6()) return true;
    }
    return false;
  }

  static private boolean jj_3R_21() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_3()) {
    jj_scanpos = xsp;
    if (jj_3R_30()) {
    jj_scanpos = xsp;
    if (jj_3R_31()) return true;
    }
    }
    return false;
  }

  static private boolean jj_3_3() {
    if (jj_scan_token(INT)) return true;
    if (jj_3R_12()) return true;
    return false;
  }

  static private boolean jj_3R_18() {
    if (jj_scan_token(LT)) return true;
    if (jj_3R_14()) return true;
    return false;
  }

  static private boolean jj_3R_24() {
    if (jj_scan_token(TRUE)) return true;
    return false;
  }

  static private boolean jj_3_1() {
    if (jj_3R_11()) return true;
    return false;
  }

  static private boolean jj_3R_17() {
    if (jj_scan_token(MULTIPLY)) return true;
    if (jj_3R_14()) return true;
    return false;
  }

  static private boolean jj_3R_23() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  static private boolean jj_3_4() {
    if (jj_scan_token(ID)) return true;
    if (jj_3R_13()) return true;
    return false;
  }

  static private boolean jj_3R_14() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_23()) {
    jj_scanpos = xsp;
    if (jj_3R_24()) {
    jj_scanpos = xsp;
    if (jj_3R_25()) {
    jj_scanpos = xsp;
    if (jj_3R_26()) {
    jj_scanpos = xsp;
    if (jj_3R_27()) {
    jj_scanpos = xsp;
    if (jj_3_10()) {
    jj_scanpos = xsp;
    if (jj_3_11()) {
    jj_scanpos = xsp;
    if (jj_3R_28()) {
    jj_scanpos = xsp;
    if (jj_3R_29()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_16() {
    if (jj_scan_token(MINUS)) return true;
    if (jj_3R_14()) return true;
    return false;
  }

  static private boolean jj_3R_29() {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  static private boolean jj_3_2() {
    if (jj_scan_token(EXTENDS)) return true;
    if (jj_scan_token(ID)) return true;
    if (jj_scan_token(LBRACE)) return true;
    return false;
  }

  static private boolean jj_3R_11() {
    if (jj_3R_21()) return true;
    if (jj_scan_token(ID)) return true;
    return false;
  }

  static private boolean jj_3R_15() {
    if (jj_scan_token(PLUS)) return true;
    if (jj_3R_14()) return true;
    return false;
  }

  static private boolean jj_3R_28() {
    if (jj_scan_token(NOT)) return true;
    return false;
  }

  static private boolean jj_3_9() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_15()) {
    jj_scanpos = xsp;
    if (jj_3R_16()) {
    jj_scanpos = xsp;
    if (jj_3R_17()) {
    jj_scanpos = xsp;
    if (jj_3R_18()) {
    jj_scanpos = xsp;
    if (jj_3R_19()) {
    jj_scanpos = xsp;
    if (jj_3R_20()) {
    jj_scanpos = xsp;
    if (jj_3_7()) {
    jj_scanpos = xsp;
    if (jj_3_8()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3_11() {
    if (jj_scan_token(NEW)) return true;
    if (jj_scan_token(ID)) return true;
    return false;
  }

  static private boolean jj_3_8() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(ID)) return true;
    return false;
  }

  static private boolean jj_3_10() {
    if (jj_scan_token(NEW)) return true;
    if (jj_scan_token(INT)) return true;
    return false;
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public ParserTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private Token jj_scanpos, jj_lastpos;
  static private int jj_la;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[18];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x200000,0x81000140,0x800200,0x4000,0x800200,0x4000,0x80000000,0x800000,0x0,0x81000140,0x81000140,0x2000000,0x800200,0x2000000,0x100f0000,0x0,0xb0000,0x10000000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x1000,0x1000,0x0,0x1000,0x0,0x0,0x1000,0x1,0x1000,0x0,0x0,0x1000,0x0,0x1408,0x371,0x1400,0x8,};
   }
  static final private JJCalls[] jj_2_rtns = new JJCalls[11];
  static private boolean jj_rescan = false;
  static private int jj_gc = 0;

  /** Constructor with InputStream. */
  public Parser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Parser(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 18; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 18; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public Parser(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 18; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 18; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public Parser(ParserTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 18; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 18; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  static final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  static private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;
  static private int[] jj_lasttokens = new int[100];
  static private int jj_endpos;

  static private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[45];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 18; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 45; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

  static private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 11; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  static private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

                     }
